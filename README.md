# DotnetCrawler
DotnetCrawler is a straightforward, lightweight web crawling/scrapying library for Entity Framework Core output based on dotnet core.
This library designed like other strong crawler libraries like WebMagic and Scrapy but for enabling extandable your custom requirements. 

## Getting Started

This project intented for providing EF.Core database insert but it has very scale architecture in order to implement your custom scenarios. So the main design of architecture is very common for web crawler/scrapying frameworks, you can see below image.

![alt text](https://raw.githubusercontent.com/dotnetcore/DotnetSpider/master/images/DESIGN.jpg)

As per above image, in this library created project structures including DotnetCrawler.Request-Downloader-Processor-Pipeline projects. 

### Usage

You can use this library using DotnetCrawler class with builder pattern;

```
 var crawler = new DotnetCrawler<Catalog>()
                                 .AddRequest(new DotnetCrawlerRequest { Url = "https://www.ebay.com/b/Apple-iPhone/9355/bn_319682", Regex = @".*itm/.+", TimeOut = 5000 })
                                 .AddDownloader(new DotnetCrawlerDownloader { DownloderType = DotnetCrawlerDownloaderType.FromMemory, DownloadPath = @"C:\DotnetCrawlercrawler\" })
                                 .AddProcessor(new DotnetCrawlerProcessor<Catalog> { })
                                 .AddPipeline(new DotnetCrawlerPipeline<Catalog> { });

await crawler.Crawle();
```
With this code, first create your request which url want to consume in your Request object. In these request object you can also provide Regex expression in order to filter your web urls. Also can able to set Timeout.


Example usage of exe;

```
InterfaceActivityBuilder.exe C:\Users\ezozkme\Desktop\Book2.xlsx
```

Or if excel file is in the same path of exe;

```
InterfaceActivityBuilder.exe Book2.xlsx
```

Also you can directly run exe file and pass path parameter in Console Aplication.

### Success of Program

After running command, program executed C# file at spesific folder location which already run existing exe file. This success message writes console as below;

```
$"SUCCESS : {className}.cs successfully created in this folder location : {currentDirectory}."
```
So you can locate particular path and see downloaded C# file which generated by InterfaceActivityBuilder.

## Requirements

Before run the program you must configure system and some assumptions should be knew.

### "AssemblyPath" Configuration Key 

Program needs to know proxy class reflection types, so before start to program you should put AssemblyPath configuration in InterfaceActivityBuilder.exe.config file.

```
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
  <appSettings>
    <add key="AssemblyPath" value="C:\source\AmxOnePeruDevelopment\AMXPeruTCRM\AmxPeruCommonLibrary\bin\Debug\AmxPeruCommonLibrary.dll" />
  </appSettings>
</configuration>
```

### Excel Format

Program required one parameter which is excel file path. So this excel file should be 2 column and these column values could be below format;

```
FieldName	CANONICO

DecisionID	ConsultarRetencionEnrutamientoRequestMessage/_customerOrder/_partyOrder/ID
solicitud	ConsultarRetencionEnrutamientoRequestMessage/_solicitud
...	
```

### Attribute Canonic Names in Excel

If there is an attribute canonic names and 2 canonic name in one row at excel, the '--' seperate character should be exist. Otherwise program cant evaluate second phrase.

```
FieldName	CANONICO

origen	"ConsultarRetencionEnrutamientoRequestMessage/_solicitud/_customerOrder/_partyRole/_service/_serviceSpecification/_serviceSpecCharacteristic/_serviceSpecCharacteristicValue/value --
ConsultarRetencionEnrutamientoRequestMessage/_solicitud/_customerOrder/_partyRole/_service/_serviceSpecification/_serviceSpecCharacteristic/name (agg=""origen"")"

...	
```

### Proxy Class Namespace

The given assembly path configuration dll should be exist proxy native classes which already generated by svcutil before. So when you create proxy class your dll, the name of the namespace should be same as generated Request Type. This is main assumption of program. Afterwards this could be take from configuration file also.

```
 #region ASSUMPTIONS !!!!!
    // ASSUMPTIONS !!!!!
    // ValidarDeudaLimiteRequestMessage
    // Proxy class should be in namespace which equals to Request message parameter and remove RequestMessage part.i.e. below proxy name space is should be ValidarDeudaLimite--RequestMessage
    // public ValidarDeudaLimiteRequestType ValidarDeudaLimiteRequestMessage;
    // ASSUMPTIONS !!!!!
#endregion

...	
```

## Background of InterfaceActivityBuilder

There are 3 module to evaluate canonic messages and convert to generated c# code.

* Excel Reader - Reads the excel and makes a record for each row in cannonic list - there is a list of lines here.
* Tree Builder - It reads the line list and translates it into Tree structure, translating the canonic string into tree structure. Special cases like Attributes added 2 times in tree as expected.
* CodePad - This module iterate the Tree and recursively generate the code and do it as a file.

## Next Releases

This program only generated request part of mapping activities with proxy classes. And this program only solve spesific problem of customer requirements. So it will evolve a product and extent with new features as listed below;

* Generate DTO classes and types acording to excel input. Also need to add new type column into excel in order to generate DTO classes with correct and complex types. 
* Generate MapResponse method which provide that load to response of native proxy class to our DTO response classes.
* Refactor CodePad module in order to decrease complexity of codes for faciliate future extentions.


## Authors

* **Mehmet Ozkaya** - *Initial work* - [mehmetozkaya](https://github.com/mehmetozkaya)

See also the list of [contributors](https://github.com/your/project/contributors) who participated in this project.

## License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details

